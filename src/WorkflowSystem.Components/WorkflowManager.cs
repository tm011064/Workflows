using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using log4net;
using Microsoft.CSharp;
using WorkflowSystem.Components.Interfaces;

namespace WorkflowSystem.Components
{
  public class WorkflowManager : IWorkflowManager
  {
    #region template
    internal const string WORKFLOW_CODE_TEMPLATE =
@"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;

using WorkflowSystem.Components;

using WorkflowSystem.Components.Interfaces;

<<usingStatements>>

namespace AutoGeneratedWorkflows
{
  public class <<className>> : IWorkflow
  {
    private Dictionary<string, string> _stepLookup = new Dictionary<string, string>();

    public <<className>>()
    {
<<stepResumeKeyValuePairs>>
    }

    public IWorkflowContext Execute()
    {
      <<contextInstance>>

      if (context.ExecutionPathNodes == null)
        context.ExecutionPathNodes = new List<IExecutionPathNode>();
      else
        context.ExecutionPathNodes.Clear();

      IExecutionPathNode executionPathNode;

      <<stepInstances>>

      <<codeBlocks>>

      context.ExecutionStatus = ExecutionStatus.Finished;

      return context;
    }    
    public IWorkflowContext Execute(IWorkflowContext ctx)
    {
      if (ctx == null)
        throw new ArgumentNullException(""No context provided."");
      
      <<contextType>> context = ctx as <<contextType>>;
      if (context == null)
        throw new Exception(""WorkflowContext object "" + ctx.GetType().ToString() + "" not of type <<contextType>>"");

      if (context.ExecutionPathNodes == null)
        context.ExecutionPathNodes = new List<IExecutionPathNode>();
      else
        context.ExecutionPathNodes.Clear();

      IExecutionPathNode executionPathNode;

      <<stepInstances>>

      <<codeBlocks>>

      context.ExecutionStatus = ExecutionStatus.Finished;

      return context;
    }    
    public IWorkflowContext Resume(IWorkflowContext ctx)
    {
      if (ctx == null)
        throw new ArgumentNullException(""No context provided."");
      
      <<contextType>> context = ctx as <<contextType>>;
      if (context == null)
        throw new Exception(""WorkflowContext object "" + ctx.GetType().ToString() + "" not of type <<contextType>>"");

      if (context.ExecutionPathNodes == null)
        context.ExecutionPathNodes = new List<IExecutionPathNode>();
      else
        context.ExecutionPathNodes.Clear();

      IExecutionPathNode executionPathNode;

      <<stepInstances>>

      <<resumeFromCodeBlock>>

      context.ExecutionStatus = ExecutionStatus.Finished;

      return context;
    }    
    public IWorkflowContext GoToStep(IWorkflowContext ctx, string stepName)
    {
      if (ctx == null)
        throw new ArgumentNullException(""No context provided."");
      
      if (string.IsNullOrEmpty(stepName))
        throw new ArgumentNullException(""No step key provided."");

      if (!_stepLookup.ContainsKey(stepName))
        throw new KeyNotFoundException(""Step "" + stepName + "" not found at workflow <<className>>"");

      ctx.ExecutionStatus = ExecutionStatus.PausedAtStep; // this will lead the resume method to start from the specified step...
      ctx.ResumeAtKey = _stepLookup[stepName];

      return Resume(ctx);
    }
  }
} 
";

    private const string EXECUTE_STEP_RESUME_TEMPLATE =
@"
if (context.ExecutionStatus == ExecutionStatus.Running
    || context.ResumeAtKey.EndsWith(""_<<stepName>>""))
{
  if (context.ExecutionStatus == ExecutionStatus.Running
      || context.ExecutionStatus == ExecutionStatus.PausedAtStep)
  {
    executionPathNode = new ExecutionPathNode(""<<stepName>>"", ""<<stepKey>>"", ExecutionPathNodeStatus.Executed);
    context.ExecutionPathNodes.Add(executionPathNode);

    try { context.ExecutionStatus = <<instanceName>>.Run(context); }
    catch (Exception err)
    {
      executionPathNode.ExecutionPathNodeStatus = ExecutionPathNodeStatus.ErrorOccurred;
      
      context.ExecutionStatus = ExecutionStatus.ExceptionOccurred;
      context.LastError = err;

      return context;
    }

    switch (context.ExecutionStatus)
    {
      case ExecutionStatus.PausedAtStep:
      case ExecutionStatus.PausedAfterStep:
      case ExecutionStatus.NavigateToStep:
      case ExecutionStatus.Cancelled:
        // we want to exit here
        <<resumeAtAssignCode>>
        return context;
    }
  }
  else
  {
    context.ExecutionPathNodes.Add(new ExecutionPathNode(""<<stepName>>"", ""<<stepKey>>"", ExecutionPathNodeStatus.Skipped));
    context.ExecutionStatus = ExecutionStatus.Running;
  }
}
else
{
  context.ExecutionPathNodes.Add(new ExecutionPathNode(""<<stepName>>"", ""<<stepKey>>"", ExecutionPathNodeStatus.Skipped));
}
";
    private const string EXECUTE_STEP_TEMPLATE =
@"
executionPathNode = new ExecutionPathNode(""<<stepName>>"", ""<<stepKey>>"", ExecutionPathNodeStatus.Executed);
context.ExecutionPathNodes.Add(executionPathNode);

try { context.ExecutionStatus = <<instanceName>>.Run(context); }
catch (Exception err)
{
  executionPathNode.ExecutionPathNodeStatus = ExecutionPathNodeStatus.ErrorOccurred;
      
  context.ExecutionStatus = ExecutionStatus.ExceptionOccurred;
  context.LastError = err;

  return context;
}

switch (context.ExecutionStatus)
{
  case ExecutionStatus.PausedAtStep:
  case ExecutionStatus.PausedAfterStep:
  case ExecutionStatus.NavigateToStep:
  case ExecutionStatus.Cancelled:
    // we want to exit here
    <<resumeAtAssignCode>>
    return context;
}
";
    #endregion

    #region members

    #region static
    private static string[] _alphabet = new string[]
    {
      "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z",
      "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z",
      "0","1","2","3","4","5","6","7","8","9","10"
    };

    #region regular expressions
    private static Regex _executeStepRegex = new Regex(@"([ ]*)@executeStep([ ]*)\(([ ]*)\""([a-zA-Z0-9_\(\)\[\]\.: ]*)\"",([ ]*)\""([a-zA-Z0-9_\., ]*)\""([ ]*)\)");
    private static Regex _ifCommandRegex = new Regex(@"^if([ ]*)\(");
    private static Regex _elseIfCommandRegex = new Regex(@"^else([ ]+)if([ ]*)\(");
    private static Regex _elseCommandRegex = new Regex(@"^else([ ]*)$");
    #endregion

    #endregion

    private Dictionary<string, IWorkflow> _workflows = new Dictionary<string, IWorkflow>();
    private ILog _Log;

    #endregion

    #region private methods
    private bool ExtractStep(List<string> lines, int lineIndex, StringBuilder output, string resumeAtKeyPrefix, Dictionary<string, string> resumeAtAssignLookup)
    {
      Match match = _executeStepRegex.Match(lines[lineIndex]);
      if (match.Success)
      {
        #region step
        string name = match.Groups[4].Value;
        Type stepType = Type.GetType(match.Groups[6].Value);

        if (stepType == null)
          throw new WorkflowCompilationException("Step Type \"" + match.Groups[6].Value + "\" not recognized");

        string instanceName = Char.ToLower(stepType.FullName[0]) + stepType.FullName.Substring(1).Replace(".", "_");
        resumeAtAssignLookup[name] = resumeAtKeyPrefix + "_" + name;

        string resumeAtAssignCode = @"context.ResumeAtKey = """ + resumeAtAssignLookup[name] + @""";";

        output.AppendLine(EXECUTE_STEP_RESUME_TEMPLATE.Replace("<<instanceName>>", instanceName)
          .Replace("<<stepName>>", name)
          .Replace("<<resumeAtAssignCode>>", resumeAtAssignCode)
          .Replace("<<stepKey>>", resumeAtAssignLookup[name]));
        #endregion

        return true;
      }

      return false;
    }

    private string ExtractBracketInformation(List<string> lines, int lineIndex, out int startIndex, out int endIndex)
    {
      int bracketCount = 0;

      startIndex = -1;
      endIndex = lineIndex + 1;

      StringBuilder conditionalStatement = new StringBuilder(lines[lineIndex]);

      while (startIndex < 0
             || (bracketCount > 0 && endIndex < lines.Count))
      {
        if (lines[endIndex] == "{")
        {
          if (startIndex < 0)
            startIndex = endIndex;

          bracketCount++;
        }

        if (startIndex < 0)
          conditionalStatement.AppendLine(lines[endIndex]);

        if (lines[endIndex] == "}")
          bracketCount--;

        endIndex++;
      }
      if (bracketCount > 0)
        throw new WorkflowCompilationException("Parse error, close bracket missing.");

      return conditionalStatement.ToString();
    }

    private int ExtractConditionalStatement(List<string> lines, int lineIndex, StringBuilder output, int indent, ref int conditionIndex
      , string parentResumeKey, Dictionary<string, string> resumeAtAssignLookup)
    {
      string formattedConditionalStatement;

      if (_alphabet.Length <= conditionIndex)
        throw new WorkflowCompilationException("Too many nested conditions. Max nested conditions allowed: " + _alphabet.Length);

      int startIndex, endIndex;
      Match match;

      match = _ifCommandRegex.Match(lines[lineIndex]);
      if (match.Success)
      {
        formattedConditionalStatement = ExtractBracketInformation(lines, lineIndex, out startIndex, out endIndex);

        parentResumeKey = parentResumeKey + _alphabet[conditionIndex];

        output.AppendLine(string.Format(
@"if ((context.ExecutionStatus == ExecutionStatus.Running
       || context.ResumeAtKey.StartsWith(""{0}"")) || ({1})"
          , parentResumeKey
          , formattedConditionalStatement.Remove(0, formattedConditionalStatement.IndexOf("(") + 1)));

        output.AppendLine("{");

        conditionIndex++;
        FormatCodeBlock(startIndex + 1, endIndex - 1, lines, output, indent + 1, 0, parentResumeKey, resumeAtAssignLookup);

        output.AppendLine("}");

        return endIndex;
      }
      match = _elseIfCommandRegex.Match(lines[lineIndex]);
      if (match.Success)
      {
        formattedConditionalStatement = ExtractBracketInformation(lines, lineIndex, out startIndex, out endIndex);

        parentResumeKey = parentResumeKey + _alphabet[conditionIndex];
        output.AppendLine(string.Format(
@"else if ((context.ExecutionStatus == ExecutionStatus.Running
       || context.ResumeAtKey.StartsWith(""{0}"")) || ({1})"
          , parentResumeKey
          , formattedConditionalStatement.Remove(0, formattedConditionalStatement.IndexOf("(") + 1)));

        output.AppendLine("{");

        conditionIndex++;
        FormatCodeBlock(startIndex + 1, endIndex - 1, lines, output, indent + 1, 0, parentResumeKey, resumeAtAssignLookup);

        output.AppendLine("}");

        return endIndex;
      }
      match = _elseCommandRegex.Match(lines[lineIndex]);
      if (match.Success)
      {
        formattedConditionalStatement = ExtractBracketInformation(lines, lineIndex, out startIndex, out endIndex);

        parentResumeKey = parentResumeKey + _alphabet[conditionIndex];

        output.AppendLine("else");
        output.AppendLine("{");

        conditionIndex++;
        FormatCodeBlock(startIndex + 1, endIndex - 1, lines, output, indent + 1, 0, parentResumeKey, resumeAtAssignLookup);

        output.AppendLine("}");

        return endIndex;
      }

      return -1;
    }

    private void FormatCodeBlock(int startIndex, int endIndex, List<string> lines, StringBuilder output
      , int indent, int conditionIndex, string parentResumeKey, Dictionary<string, string> resumeAtAssignLookup)
    {
      for (int i = startIndex; i < endIndex; i++)
      {
        if (ExtractStep(lines, i, output, parentResumeKey, resumeAtAssignLookup))
          continue;

        int conditionalStatementEndIndex = ExtractConditionalStatement(lines, i, output, indent
          , ref conditionIndex, parentResumeKey, resumeAtAssignLookup);
        if (conditionalStatementEndIndex >= 0)
        {
          i = conditionalStatementEndIndex - 1;
          continue;
        }

        output.AppendLine(lines[i]);
      }
    }

    private string BuildResumeFromCode(List<string> lines, Dictionary<string, string> resumeAtAssignLookup)
    {
      StringBuilder output = new StringBuilder();

      FormatCodeBlock(0, lines.Count, lines, output, 0, 0, string.Empty, resumeAtAssignLookup);

      return output.ToString();
    }

    private void CompileCode(string code, string workflowName)
    {
      CSharpCodeProvider csp = new CSharpCodeProvider();

      CompilerParameters cp = new CompilerParameters();
      cp.GenerateExecutable = false;
      cp.GenerateInMemory = false;
      cp.TreatWarningsAsErrors = false;

      cp.ReferencedAssemblies.Add(Assembly.GetExecutingAssembly().Location);
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
      {
        try
        {
          string location = assembly.Location;
          if (!string.IsNullOrEmpty(location))
            cp.ReferencedAssemblies.Add(location);
        }
        catch (NotSupportedException)
        {
          // this happens for dynamic assemblies, so just ignore it.
        }
      }

      CompilerResults compilerResults = csp.CompileAssemblyFromSource(cp, code);
      if (!compilerResults.Errors.HasErrors)
      {
        _Log.Debug("Successfully compiled workflow " + workflowName);
        _workflows[workflowName] = compilerResults.CompiledAssembly.CreateInstance("AutoGeneratedWorkflows." + workflowName) as IWorkflow;
      }
      else
      {
        StringBuilder errorMessage = new StringBuilder("Error occurred while compiling workflow \"" + workflowName + "\". Errors: ");
        foreach (CompilerError error in compilerResults.Errors)
          errorMessage.AppendLine((error.IsWarning ? "warning: " : "error: ") + error.ErrorText);

        _Log.Debug(errorMessage.ToString());
        throw new WorkflowCompilationException(compilerResults.Errors);
      }
    }

    private void DoCompileWorkflow(string workflowName, string usingStatements, string contextTypeName, string scriptValue)
    {
      Type type = Type.GetType(contextTypeName);

      List<string> lines = new List<string>();
      StringBuilder scriptBuilder = new StringBuilder();

      string l;
      foreach (string line in scriptValue.Split(Environment.NewLine.ToCharArray()))
      {
        if (!string.IsNullOrEmpty(line))
        {
          l = line.Trim();

          int commentIndex = l.IndexOf("//");
          if (commentIndex >= 0)
            l = l.Remove(commentIndex).Trim();

          lines.Add(l);
          scriptBuilder.AppendLine(l);
        }
        string script = scriptBuilder.ToString();

        Dictionary<string, string> resumeAtAssignLookup = new Dictionary<string, string>();
        // this needs to be done before building the execute path...
        string resumeFromCode = BuildResumeFromCode(lines, resumeAtAssignLookup).Replace("@context", "context").ToString();

        StringBuilder stepResumeKeyValuePairs = new StringBuilder();
        foreach (var kvp in resumeAtAssignLookup)
        {
          stepResumeKeyValuePairs.AppendLine(@"     _stepLookup[""" + kvp.Key + @"""] = """ + kvp.Value + @""";");
        }

        HashSet<string> instances = new HashSet<string>();
        HashSet<string> keys = new HashSet<string>();

        StringBuilder instanciation = new StringBuilder();
        string contextInstance = type.FullName + " context = new " + type.FullName + "();";
        string contextType = type.FullName;

        string parsed = _executeStepRegex.Replace(script, delegate(Match match)
        {
          string name = match.Groups[4].Value;
          string stepTypeName = match.Groups[6].Value;

          Type stepType = Type.GetType(stepTypeName);

          string instanceName = Char.ToLower(stepType.FullName[0]) + stepType.FullName.Substring(1).Replace(".", "_");
          if (!instances.Contains(instanceName))
          {
            instances.Add(instanceName);
            instanciation.AppendLine(string.Format("{0} {1} = new {0}();", stepType.FullName, instanceName));
          }

          return EXECUTE_STEP_TEMPLATE.Replace("<<instanceName>>", instanceName)
                                      .Replace("<<stepName>>", name)
                                      .Replace("<<resumeAtAssignCode>>", resumeAtAssignLookup.ContainsKey(name) ? (@"context.ResumeAtKey = """ + resumeAtAssignLookup[name] + @""";")
                                                                                                                : string.Empty)
                                      .Replace("<<stepKey>>", resumeAtAssignLookup[name]);
        });
        parsed = parsed.Replace("@context", "context");

        string fullCode = WORKFLOW_CODE_TEMPLATE
          .Replace("<<className>>", workflowName)
          .Replace("<<stepInstances>>", instanciation.ToString())
          .Replace("<<codeBlocks>>", parsed)
          .Replace("<<contextInstance>>", contextInstance)
          .Replace("<<contextType>>", contextType)
          .Replace("<<usingStatements>>", usingStatements)
          .Replace("<<stepResumeKeyValuePairs>>", stepResumeKeyValuePairs.ToString().TrimEnd(','))
          .Replace("<<resumeFromCodeBlock>>", resumeFromCode);

        _Log.Debug("Compiling workflow " + workflowName);

        // we have fully working code...
        CompileCode(fullCode, workflowName);
      }
    }
    #endregion

    #region public methods

    public IWorkflowContext ExecuteWorkflow(string workflowName, IWorkflowContext context)
    {
      if (!_workflows.ContainsKey(workflowName))
        throw new ArgumentException("Workflow '" + workflowName + "' not recognized.");

      if (context != null)
        return _workflows[workflowName].Execute(context);
      else
        return _workflows[workflowName].Execute();
    }

    public IWorkflowContext ExecuteWorkflow(string workflowName)
    {
      if (!_workflows.ContainsKey(workflowName))
        throw new ArgumentException("Workflow '" + workflowName + "' not recognized.");

      return _workflows[workflowName].Execute();
    }

    public IWorkflowContext ResumeWorkflow(string workflowName, IWorkflowContext context)
    {
      if (!_workflows.ContainsKey(workflowName))
        throw new ArgumentException("Workflow '" + workflowName + "' not recognized.");

      return _workflows[workflowName].Resume(context);
    }

    public IWorkflowContext ResumeWorkflowFromStep(string workflowName, string stepName, IWorkflowContext context)
    {
      if (!_workflows.ContainsKey(workflowName))
        throw new ArgumentException("Workflow '" + workflowName + "' not recognized.");

      return _workflows[workflowName].GoToStep(context, stepName);
    }

    public void CompileWorkflows(WorkflowConfigSection workflowConfigSection)
    {
      string workflowName;

      StringBuilder usingStatements = new StringBuilder();
      foreach (WorkflowElement workflowElement in workflowConfigSection.Workflows)
      {
        if (string.IsNullOrWhiteSpace(workflowElement.Name))
          throw new WorkflowCompilationException("All workflows must have a name.");

        workflowName = workflowElement.Name;
        _Log.Debug("Building workflow \"" + workflowName + "\"...");

        usingStatements.Remove(0, usingStatements.Length);
        foreach (UsingElement usingElement in workflowElement.Namespaces.Get())
          usingStatements.AppendLine("using " + usingElement.Namespace + ";");

        if (workflowElement.RundownElement != null)
        {
          DoCompileWorkflow(
            workflowName
            , usingStatements.ToString()
            , workflowElement.RundownElement.ContextType
            , workflowElement.RundownElement.Value);
        }
      }
    }

    public void CompileWorkflows(XContainer container)
    {
      XAttribute attribute;
      string typeName;
      string workflowName;

      StringBuilder usingStatements = new StringBuilder();

      foreach (XElement workflowElement in container.Descendants("workflow"))
      {
        attribute = workflowElement.Attribute("name");
        if (attribute == null)
          throw new WorkflowCompilationException("All workflows must have a name.");

        workflowName = attribute.Value;
        _Log.Debug("Building workflow \"" + workflowName + "\"...");

        usingStatements.Remove(0, usingStatements.Length);

        XElement namespaces = workflowElement.Element("namespaces");
        if (namespaces != null)
        {
          foreach (XElement usingElement in namespaces.Elements("using"))
          {
            attribute = usingElement.Attribute("namespace");
            if (attribute != null)
            {
              usingStatements.AppendLine("using " + attribute.Value + ";");
            }
          }
        }

        XElement rundown = workflowElement.Element("rundown");
        if (rundown != null)
        {
          typeName = null;
          attribute = rundown.Attribute("contextType");
          if (attribute != null)
            typeName = attribute.Value;

          DoCompileWorkflow(
            workflowName
            , usingStatements.ToString()
            , typeName
            , rundown.Value);
        }
      }
    }

    #endregion

    #region constructors
    public WorkflowManager()
    {
      _Log = LogManager.GetLogger(this.GetType().FullName);
    }
    #endregion
  }
}
